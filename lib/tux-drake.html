<!--
@license
Copyright (c) 2015 Tux Authors
This code is distributed under the MIT license.  See LICENSE.txt for
details.

@description a set of elements that encapsulate the excellent dragula.js
@group elements
@dependency dragula dragula.js
@dependency tux-draggable trustifier/tux-draggable.html
@dependency tux-drop-zone trustifier/tux-drop-zone.html

@demo
-->
<script src='../../dragula.js/dist/dragula.js'></script>
<link rel="import" href="../../polymer/polymer.html">
<dom-module id='tux-drake'>
  <script>
    Polymer({
      is: 'tux-drake',
      properties: {
      },

      _drake: null,

      created: function() {
        var self = this;
        this._drake = dragula({
          invalid: function(el, target) {
            if(el.hasAttribute('not-draggable')) {
              return true;
            }
            return false;
          },
          accepts: function(el, target, source, sibling) {
            [el, target, source].forEach(function(f) {
              f.zones = (!f.zones && f.hasAttribute('zones'))
                ? f.getAttribute('zones')
                : f.zones;
            });

            if ( !target.zones || !(source.zones || el.zones)) {
               // we can add strict zoning here later
               // by looking for an extra flag like strict-zones
               // on the element or source, in which case
               // this would become false
              return true;
            }

            var szA = (el.zones ? el.zones : source.zones).split(/[,|\s]+/);
            var tzA = target.zones.split(/[,|\s]+/);
            return szA.some(function(m) {
              return (tzA.indexOf(m) !== -1);
            });
          }
        });
        this._drake.on('drag', this.dragging);
        this._drake.on('drop', this.dropped);
        this._drake.on('dragend', this.dragEnd);
        this._drake.on('cancel', this.dragCancel);
      },

      /**
       * @param {Element} elements that we want to attach to
       */
      dragging: function(el, source) {
        el.fire = ('fire' in el && el.fire) || Polymer.Base.fire;
        el.fire('drag', { 'drake': this, 'element': el, 'source': source });
        source.fire = ('fire' in source && source.fire) || Polymer.Base.fire;
        source.fire('drag', { 'drake': this, 'element': el, 'source': source });
      },

      dropped: function(el, target, source) {
        el.fire = ('fire' in el && el.fire) || Polymer.Base.fire;
        el.fire('drop', { 'drake': this, 'element': el, 'target': target, 'source': source });
        source.fire = ('fire' in source && source.fire) || Polymer.Base.fire;
        source.fire('drop', { 'drake': this, 'element': el, 'target': target, 'source': source });
        target.fire = ('fire' in target && target.fire) || Polymer.Base.fire;
        target.fire('drop', { 'drake': this, 'element': el, 'target': target, 'source': source });
      },
      dragEnd: function(el) {
        el.fire = ('fire' in el && el.fire) || Polymer.Base.fire;
        el.fire('drag-ended', { 'drake': this });
      },
      dragCancel: function(el, source) {
        el.fire = ('fire' in el && el.fire) || Polymer.Base.fire;
        el.fire('drag-canceled', { 'drake': this,'element': el,  'source': source });
        source.fire = ('fire' in source && source.fire) || Polymer.Base.fire;
        source.fire('drag-canceled', { 'drake': this, 'element': el, 'source': source });
      },
      register: function(el) {
        this.async(function() {
          if(this._drake.containers.indexOf(el) < 0 ) {
            this._drake.containers.push(el);
          }
        });
      },
      unregister: function(el) {
        var idx = this._drake.containers.indexOf(el);
        if(idx >= 0) {
          this._drake.containers.splice(idx, 1);
        }
      }
    });
  </script>
</dom-module>
